---
# This workflow builds and deploys
# the Orchestration Library UI
# and deploys it to a Kubernetes cluster using Helm.

name: Build and Deploy the Orchestration Library UI

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - '**'

env:
  # Enable detailed logging
  ACTIONS_STEP_DEBUG: true
  ACTIONS_RUNNER_DEBUG: true

jobs:
  checkout:
    name: ğŸ”„ Checkout Code
    runs-on: ubuntu-latest
    outputs:
      repo-path: ${{ steps.set-repo-path.outputs.repo-path }}
      build-timestamp: ${{ steps.set-timestamp.outputs.timestamp }}
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ“Š Display workflow context
        run: |
          echo "::group::ğŸ” Workflow Context Information"
          echo "Repository: ${{ github.repository }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Event: ${{ github.event_name }}"
          echo "Actor: ${{ github.actor }}"
          echo "Run ID: ${{ github.run_id }}"
          echo "Run Number: ${{ github.run_number }}"
          echo "Commit SHA: ${{ github.sha }}"
          echo "Workspace: ${GITHUB_WORKSPACE}"
          echo "::endgroup::"

      - name: ğŸ• Set build timestamp
        id: set-timestamp
        run: |
          TIMESTAMP=$(date -u +"%Y%m%d-%H%M%S")
          echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT
          echo "ğŸ“… Build timestamp: ${TIMESTAMP}"

      - name: ğŸ“‚ Set repository path
        id: set-repo-path
        run: |
          echo "repo-path=${GITHUB_WORKSPACE}" >> $GITHUB_OUTPUT
          echo "ğŸ“‚ Repository path: ${GITHUB_WORKSPACE}"

  validate:
    name: âœ… Validate & Test
    runs-on: ubuntu-latest
    needs: checkout
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Validate pnpm lockfile
        run: |
          echo "::group::ğŸ” PNPM Lockfile Validation"
          if [ -f "pnpm-lock.yaml" ]; then
            echo "âœ… pnpm-lock.yaml found"
            echo "ğŸ“Š Lockfile size: $(wc -c < pnpm-lock.yaml) bytes"
            echo "ğŸ“… Last modified: $(stat -c %y pnpm-lock.yaml 2>/dev/null || stat -f %Sm pnpm-lock.yaml)"
          else
            echo "âŒ pnpm-lock.yaml not found!"
            echo "Available files:"
            ls -la
            exit 1
          fi
          echo "::endgroup::"

      - name: ğŸ“Š Display validation context
        run: |
          echo "::group::ğŸ” Validation Context"
          echo "Node.js setup starting..."
          echo "Validation timestamp: $(date -u)"
          echo "Working directory: $(pwd)"
          echo "Available disk space: $(df -h . | tail -1 | awk '{print $4}')"
          echo "::endgroup::"

      - name: ğŸŸ¢ Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: ğŸ“¦ Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: latest

      - name: ğŸ”„ Setup Node.js with pnpm cache
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - name: ğŸ” Show environment versions
        run: |
          echo "::group::ğŸ” Environment Versions"
          echo "Node.js: $(node -v)"
          echo "npm: $(npm -v)"
          echo "pnpm: $(pnpm -v)"
          echo "OS: $(uname -a)"
          echo "::endgroup::"

      - name: ğŸ“¥ Install project dependencies
        run: |
          echo "::group::ğŸ“¥ Installing Dependencies"
          echo "Starting dependency installation at: $(date -u)"
          echo "Package manager: pnpm"

          # Show memory usage before installation
          echo "Memory usage before installation:"
          free -h

          pnpm install --frozen-lockfile

          echo "âœ… Dependencies installed successfully at: $(date -u)"
          echo "::endgroup::"

      - name: ğŸ—ï¸ Validate build process
        run: |
          echo "::group::ğŸ—ï¸ Build Validation"
          echo "Starting build validation at: $(date -u)"

          # Check if build command exists
          if pnpm run --help | grep -q "build:prod"; then
            echo "âœ… build:prod script found"
          else
            echo "âŒ build:prod script not found"
            echo "Available scripts:"
            pnpm run --help
          fi

          # Validate TypeScript configuration
          if [ -f "tsconfig.json" ]; then
            echo "âœ… TypeScript configuration found"
          else
            echo "âŒ TypeScript configuration missing"
          fi

          # Check Angular configuration
          if [ -f "angular.json" ] || [ -f "project.json" ]; then
            echo "âœ… Angular configuration found"
          else
            echo "âŒ Angular configuration missing"
          fi

          echo "::endgroup::"

      # Uncomment when tests are ready
      # - name: ğŸ§ª Run tests
      #   run: |
      #     echo "::group::ğŸ§ª Running Tests"
      #     echo "Starting tests at: $(date -u)"
      #     pnpm test
      #     echo "âœ… Tests completed at: $(date -u)"
      #     echo "::endgroup::"

      - name: ğŸ¯ Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: ğŸ” Show Helm version
        run: |
          echo "::group::ğŸ” Helm Information"
          echo "Helm version: $(helm version --short)"
          echo "Helm client version: $(helm version --client --short)"
          echo "::endgroup::"

      - name: ğŸ” Validate Helm chart
        run: |
          echo "::group::ğŸ” Helm Chart Validation"
          echo "Starting Helm chart validation at: $(date -u)"

          CHART_PATH="./charts/orchestrator-library-ui"

          if [ -d "$CHART_PATH" ]; then
            echo "âœ… Chart directory found: $CHART_PATH"

            # Show chart structure
            echo "ğŸ“‚ Chart structure:"
            find "$CHART_PATH" -type f -name "*.yaml" -o -name "*.yml" | head -20

            # Validate chart syntax
            echo "ğŸ” Running helm lint..."
            helm lint "$CHART_PATH" --debug

            # Dry run template generation
            echo "ğŸ” Testing template generation..."
            helm template test-release "$CHART_PATH" \
              --set app.image.repository=test-image \
              --set app.image.tag=test-tag \
              --dry-run > /tmp/helm-test.yaml

            echo "âœ… Helm templates generated successfully"
            echo "ğŸ“Š Generated manifests size: $(wc -l < /tmp/helm-test.yaml) lines"

          else
            echo "âŒ Chart directory not found: $CHART_PATH"
            exit 1
          fi

          echo "âœ… Helm chart validation completed at: $(date -u)"
          echo "::endgroup::"

  build-and-push:
    name: ğŸ³ Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: validate
    outputs:
      image_name: ${{ steps.set-image.outputs.image_name }}
      image_tag: ${{ steps.set-image.outputs.image_tag }}
      build_duration: ${{ steps.build-stats.outputs.duration }}
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“Š Display build context
        run: |
          echo "::group::ğŸ” Build Context Information"
          echo "Building at: $(date -u)"
          echo "Docker version: $(docker --version)"
          echo "Available disk space: $(df -h . | tail -1 | awk '{print $4}')"
          echo "Available memory: $(free -h | head -2 | tail -1 | awk '{print $7}')"
          echo "CPU cores: $(nproc)"
          echo "::endgroup::"

      - name: ğŸ”‘ Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: ğŸ” Validate Docker environment
        run: |
          echo "::group::ğŸ” Docker Environment"
          echo "Docker info:"
          docker info | head -20

          echo "Docker system df:"
          docker system df

          echo "Available Docker images:"
          docker images | head -10
          echo "::endgroup::"

      - name: ğŸ—ï¸ Build Docker image
        id: set-image
        run: |
          echo "::group::ğŸ—ï¸ Docker Build Process"

          BUILD_START=$(date +%s)
          IMAGE_TAG=${{ vars.ORCHESTRATOR_LIBRARY_UI_IMAGE_TAG }}-$(date +%Y%m%d%H%M%S)
          IMAGE_NAME=${{ vars.ORCHESTRATOR_LIBRARY_UI_IMAGE_NAME }}
          FULL_IMAGE_NAME="${IMAGE_NAME}:${IMAGE_TAG}"

          echo "ğŸ·ï¸ Building image: ${FULL_IMAGE_NAME}"
          echo "â° Build started at: $(date -u)"

          # Build with detailed output
          docker build \
            -t "${FULL_IMAGE_NAME}" \
            --build-arg BUILD_DATE="$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            --build-arg BUILD_VERSION="${IMAGE_TAG}" \
            --build-arg GIT_COMMIT="${{ github.sha }}" \
            --progress=plain \
            .

          BUILD_END=$(date +%s)
          BUILD_DURATION=$((BUILD_END - BUILD_START))

          echo "âœ… Build completed successfully!"
          echo "â±ï¸ Build duration: ${BUILD_DURATION} seconds"
          echo "ğŸ“Š Image size: $(docker images ${FULL_IMAGE_NAME} --format 'table {{.Size}}')"

          # Set outputs
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "build_duration=${BUILD_DURATION}" >> $GITHUB_OUTPUT

          echo "::endgroup::"

      - name: ğŸ“Š Image inspection
        run: |
          echo "::group::ğŸ“Š Docker Image Details"
          FULL_IMAGE_NAME="${{ steps.set-image.outputs.image_name }}:${{ steps.set-image.outputs.image_tag }}"

          echo "ğŸ” Image details:"
          docker inspect "${FULL_IMAGE_NAME}" | head -50

          echo "ğŸ“‹ Image layers:"
          docker history "${FULL_IMAGE_NAME}"

          echo "ğŸ·ï¸ Image labels:"
          docker inspect "${FULL_IMAGE_NAME}" --format='{{json .Config.Labels}}' | jq -r 'to_entries[] | "\(.key)=\(.value)"' || echo "No labels found"

          echo "::endgroup::"

      - name: ğŸ§ª Test Docker image
        run: |
          echo "::group::ğŸ§ª Docker Image Testing"
          FULL_IMAGE_NAME="${{ steps.set-image.outputs.image_name }}:${{ steps.set-image.outputs.image_tag }}"

          echo "ğŸƒ Starting test container..."
          CONTAINER_ID=$(docker run -d --name test-container -p 8080:80 "${FULL_IMAGE_NAME}")

          echo "â³ Waiting for container to be ready..."
          sleep 10

          echo "ğŸ” Container status:"
          docker ps -a --filter name=test-container

          echo "ğŸ“‹ Container logs:"
          docker logs test-container

          echo "ğŸŒ Testing HTTP response..."
          if curl -f -s -o /dev/null -w "%{http_code}" http://localhost:8080 | grep -q "200"; then
            echo "âœ… Container responding correctly"
          else
            echo "âŒ Container not responding correctly"
            docker logs test-container
            exit 1
          fi

          echo "ğŸ§¹ Cleaning up test container..."
          docker stop test-container
          docker rm test-container

          echo "::endgroup::"

      - name: ğŸš€ Push Docker image
        if: github.event_name == 'push'
        run: |
          echo "::group::ğŸš€ Docker Push Process"
          FULL_IMAGE_NAME="${{ steps.set-image.outputs.image_name }}:${{ steps.set-image.outputs.image_tag }}"

          echo "ğŸ“¤ Pushing image: ${FULL_IMAGE_NAME}"
          echo "â° Push started at: $(date -u)"

          PUSH_START=$(date +%s)
          docker push "${FULL_IMAGE_NAME}"
          PUSH_END=$(date +%s)
          PUSH_DURATION=$((PUSH_END - PUSH_START))

          echo "âœ… Image pushed successfully!"
          echo "â±ï¸ Push duration: ${PUSH_DURATION} seconds"
          echo "ğŸ“ Image location: docker.io/${FULL_IMAGE_NAME}"

          echo "::endgroup::"

      - name: ğŸ“Š Build statistics
        id: build-stats
        run: |
          echo "::group::ğŸ“Š Build Statistics Summary"
          echo "ğŸ—ï¸ Build duration: ${{ steps.set-image.outputs.build_duration }} seconds"
          echo "ğŸ·ï¸ Image tag: ${{ steps.set-image.outputs.image_tag }}"
          echo "ğŸ“¦ Image name: ${{ steps.set-image.outputs.image_name }}"
          echo "ğŸ“Š Final image size: $(docker images ${{ steps.set-image.outputs.image_name }}:${{ steps.set-image.outputs.image_tag }} --format '{{.Size}}')"
          echo "â° Build completed at: $(date -u)"
          echo "duration=${{ steps.set-image.outputs.build_duration }}" >> $GITHUB_OUTPUT
          echo "::endgroup::"

  deploy:
    name: ğŸš€ Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs:
      - build-and-push
    strategy:
      matrix:
        kubeconfig_secret_name: [HIRO_KUBE_CONFIG_AWS, HIRO_KUBE_CONFIG_BASTON]
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“Š Display deployment context
        run: |
          echo "::group::ğŸ” Deployment Context"
          echo "Deploying at: $(date -u)"
          echo "Image: ${{ needs.build-and-push.outputs.image_name }}:${{ needs.build-and-push.outputs.image_tag }}"
          echo "Event type: ${{ github.event_name }}"
          echo "Target namespace: ${{ vars.ORCHESTRATOR_LIBRARY_UI_NAMESPACE }}"
          echo "Release name: ${{ vars.ORCHESTRATOR_LIBRARY_UI_RELEASE_NAME }}"
          echo "Build duration: ${{ needs.build-and-push.outputs.build_duration }} seconds"
          echo "::endgroup::"

      - name: âš™ï¸ Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: ğŸ¯ Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: ğŸ” Show tool versions
        run: |
          echo "::group::ğŸ” Deployment Tools"
          echo "kubectl version: $(kubectl version --client --short)"
          echo "Helm version: $(helm version --short)"
          echo "::endgroup::"

      - name: ğŸ”‘ Set up kubeconfig
        run: |
          echo "::group::ğŸ”‘ Kubernetes Configuration"
          mkdir -p ~/.kube
          echo "${{ secrets[matrix.kubeconfig_secret_name] }}" > ~/.kube/${{ matrix.kubeconfig_secret_name }}
          chmod 600 ~/.kube/${{ matrix.kubeconfig_secret_name }}

          echo "âœ… Kubeconfig file created"
          echo "ğŸ“Š Config file size: $(wc -c < ~/.kube/${{ matrix.kubeconfig_secret_name }}) bytes"

          # Test connection (without exposing sensitive data)
          if kubectl cluster-info --kubeconfig ~/.kube/${{ matrix.kubeconfig_secret_name }} > /dev/null 2>&1; then
            echo "âœ… Kubernetes cluster connection successful"
            echo "ğŸ¯ Current context: $(kubectl config current-context --kubeconfig ~/.kube/${{ matrix.kubeconfig_secret_name }})"
          else
            echo "âŒ Failed to connect to Kubernetes cluster"
            exit 1
          fi
          echo "::endgroup::"

      - name: ğŸ¯ Set deployment mode
        id: helm-dry-run
        run: |
          echo "::group::ğŸ¯ Deployment Mode Configuration"
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "flag=" >> $GITHUB_OUTPUT
            echo "ğŸš€ Production deployment mode (actual deployment)"
          else
            echo "flag=--dry-run" >> $GITHUB_OUTPUT
            echo "ğŸ§ª Dry-run mode (validation only)"
          fi
          echo "::endgroup::"

      - name: Set Helm values for Service type and Ingress
        id: helm-app-access
        run: |
          if [[ "${{ matrix.kubeconfig_secret_name }}" == "HIRO_KUBE_CONFIG_AWS" ]]; then
            echo "orchestrator_ui_service_type=--set app.service.type=NodePort" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_service_nodePort=--set app.service.nodePort=${{ vars.ORCHESTRATOR_LIBRARY_UI_NODE_PORT }}" >> $GITHUB_OUTPUT            
            echo "orchestrator_ui_ingress_enabled=--set app.ingress.enabled=false" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_ingress_host=" >> $GITHUB_OUTPUT
            echo "k8s_proxy_service_type=--set app.k8sProxy.service.type=NodePort" >> $GITHUB_OUTPUT
            echo "k8s_proxy_service_nodePort=--set app.k8sProxy.service.nodePort=${{ vars.K8S_PROXY_NODE_PORT }}" >> $GITHUB_OUTPUT
            echo "k8s_proxy_ingress_enabled=--set app.k8sProxy.ingress.enabled=false" >> $GITHUB_OUTPUT
            echo "k8s_proxy_ingress_host=" >> $GITHUB_OUTPUT
          else
            echo "orchestrator_ui_service_type=--set app.service.type=ClusterIP" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_service_nodePort=" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_ingress_enabled=--set app.ingress.enabled=true" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_ingress_host=--set app.ingress.host=${{ vars.ORCHESTRATOR_LIBRARY_UI_INGRESS_HOST }}" >> $GITHUB_OUTPUT
            echo "k8s_proxy_service_type=--set app.k8sProxy.service.type=ClusterIP" >> $GITHUB_OUTPUT
            echo "k8s_proxy_service_nodePort=" >> $GITHUB_OUTPUT
            echo "k8s_proxy_ingress_enabled=--set app.k8sProxy.ingress.enabled=true" >> $GITHUB_OUTPUT
            echo "k8s_proxy_ingress_host=--set app.k8sProxy.ingress.host=${{ vars.K8S_PROXY_INGRESS_HOST }}" >> $GITHUB_OUTPUT
          fi

      - name: Set Helm values for environment targets
        id: helm-app-env
        run: |
          if [[ "${{ matrix.kubeconfig_secret_name }}" == "HIRO_KUBE_CONFIG_AWS" ]]; then
            echo "orchestrator_ui_env_k8s_proxy_target=http://51.44.28.47:${{ vars.K8S_PROXY_NODE_PORT }}" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_env_api_target=http://51.44.28.47:30015" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_env_dex_target=http://51.44.28.47:30080" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_env_dashboard_target=http://51.44.28.47:30016" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_env_grafana_target=http://51.44.28.47:30000" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_env_cog_target=https://cui-nine.vercel.app/?is_iframe=1" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_env_oidc_auth=http://51.44.28.47:30015/dex" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_env_oidc_redirect=http://51.44.28.47:30015/authservice/oidc/callback" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_env_oidc_post_logout=http://51.44.28.47:30015/auth/login" >> $GITHUB_OUTPUT
          else
            echo "orchestrator_ui_env_k8s_proxy_target=https://${{ vars.K8S_PROXY_INGRESS_HOST }}" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_env_api_target=https://orchestration-api.aces.hiro-develop.nl" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_env_dex_target=https://dex.aces.hiro-develop.nl" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_env_dashboard_target=https://k8s-dashboard.aces.hiro-develop.nl" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_env_grafana_target=https://grafana.aces.hiro-develop.nl" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_env_cog_target=https://cui-nine.vercel.app/?is_iframe=1" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_env_oidc_auth=https://orchestration-api.aces.hiro-develop.nl/dex" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_env_oidc_redirect=https://orchestration-api.aces.hiro-develop.nl/authservice/oidc/callback" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_env_oidc_post_logout=https://orchestration-api.aces.hiro-develop.nl/auth/login" >> $GITHUB_OUTPUT
          fi

      - name: Deploy Orchestrator Library UI Helm chart
        env:
          RELEASE_NAME: ${{ vars.ORCHESTRATOR_LIBRARY_UI_RELEASE_NAME }} # used in post-renderer script
        run: |
          echo "::group::ğŸš€ Helm Deployment Process"

          DEPLOY_START=$(date +%s)

          echo "ğŸ“‹ Deployment parameters:"
          echo "  Release: ${{ vars.ORCHESTRATOR_LIBRARY_UI_RELEASE_NAME }}"
          echo "  Namespace: ${{ vars.ORCHESTRATOR_LIBRARY_UI_NAMESPACE }}"
          echo "  Image: ${{ vars.ORCHESTRATOR_LIBRARY_UI_IMAGE_NAME }}:${{ needs.build-and-push.outputs.image_tag }}"
          echo "  Node Port: ${{ vars.ORCHESTRATOR_LIBRARY_UI_NODE_PORT }}"
          echo "  K8s Proxy Port: ${{ vars.K8S_PROXY_NODE_PORT }}"
          echo "  K8s Proxy Ingress: ${{ vars.K8S_PROXY_INGRESS_HOST }}"
          echo "  Kubeconfig: ${{ matrix.kubeconfig_secret_name }}"
          echo "  Mode: ${{ steps.helm-dry-run.outputs.flag && 'DRY RUN' || 'PRODUCTION' }}"

          echo "ğŸ—ï¸ Starting Helm deployment..."

          helm upgrade --install ${{ vars.ORCHESTRATOR_LIBRARY_UI_RELEASE_NAME }} ./charts/orchestrator-library-ui \
            --post-renderer ./charts/orchestrator-library-ui/add-common-labels.sh \
            --kubeconfig ~/.kube/${{ matrix.kubeconfig_secret_name }} \
            --namespace ${{ vars.ORCHESTRATOR_LIBRARY_UI_NAMESPACE }} \
            --create-namespace \
            --set namespace=${{ vars.ORCHESTRATOR_LIBRARY_UI_NAMESPACE }} \
            --set app.name=${{ vars.ORCHESTRATOR_LIBRARY_UI_RELEASE_NAME }} \
            --set app.image.repository=${{ vars.ORCHESTRATOR_LIBRARY_UI_IMAGE_NAME }} \
            --set app.image.tag=${{ needs.build-and-push.outputs.image_tag }} \
            ${{ steps.helm-app-access.outputs.orchestrator_ui_service_type }} \
            ${{ steps.helm-app-access.outputs.orchestrator_ui_service_nodePort }} \
            ${{ steps.helm-app-access.outputs.orchestrator_ui_ingress_enabled }} \
            ${{ steps.helm-app-access.outputs.orchestrator_ui_ingress_host }} \
            --set app.env.K8S_PROXY_TARGET=${{ steps.helm-app-env.outputs.orchestrator_ui_env_k8s_proxy_target }} \
            --set app.env.API_TARGET=${{ steps.helm-app-env.outputs.orchestrator_ui_env_api_target }} \
            --set app.env.DEX_TARGET=${{ steps.helm-app-env.outputs.orchestrator_ui_env_dex_target }} \
            --set app.env.DASHBOARD_TARGET=${{ steps.helm-app-env.outputs.orchestrator_ui_env_dashboard_target }} \
            --set app.env.GRAFANA_TARGET=${{ steps.helm-app-env.outputs.orchestrator_ui_env_grafana_target }} \
            --set app.env.COG_TARGET=${{ steps.helm-app-env.outputs.orchestrator_ui_env_cog_target }} \
            --set app.env.OIDC_AUTHORITY=${{ steps.helm-app-env.outputs.orchestrator_ui_env_oidc_auth }} \
            --set app.env.OIDC_REDIRECT_URI=${{ steps.helm-app-env.outputs.orchestrator_ui_env_oidc_redirect }} \
            --set app.env.OIDC_POST_LOGOUT_REDIRECT_URI=${{ steps.helm-app-env.outputs.orchestrator_ui_env_oidc_post_logout }} \
            --set app.k8sProxy.enabled=true \
            ${{ steps.helm-app-access.outputs.k8s_proxy_service_type }} \
            ${{ steps.helm-app-access.outputs.k8s_proxy_service_nodePort }} \
            ${{ steps.helm-app-access.outputs.k8s_proxy_ingress_enabled }} \
            ${{ steps.helm-app-access.outputs.k8s_proxy_ingress_host }} \
            --set app.k8sProxy.env.API_BACKEND_URL=${{ steps.helm-app-env.outputs.orchestrator_ui_env_api_target }} \
            --set app.k8sProxy.env.K8S_DASHBOARD_URL=${{ steps.helm-app-env.outputs.orchestrator_ui_env_dashboard_target }} \
            --set app.k8sProxy.env.K8S_NAMESPACE=hiros \
            --set app.k8sProxy.env.K8S_SERVICE_ACCOUNT=readonly-user \
            --timeout=600s \
            --wait \
            --debug \
            ${{ steps.helm-dry-run.outputs.flag }}

          DEPLOY_END=$(date +%s)
          DEPLOY_DURATION=$((DEPLOY_END - DEPLOY_START))

          echo "âœ… Helm deployment completed!"
          echo "â±ï¸ Deployment duration: ${DEPLOY_DURATION} seconds"

          echo "::endgroup::"

      - name: ğŸ” Verify deployment status
        if: github.event_name == 'push'
        run: |
          echo "::group::ğŸ” Deployment Verification"

          echo "â³ Waiting for deployment to stabilize..."
          sleep 30

          NAMESPACE="${{ vars.ORCHESTRATOR_LIBRARY_UI_NAMESPACE }}"
          RELEASE_NAME="${{ vars.ORCHESTRATOR_LIBRARY_UI_RELEASE_NAME }}"
          KUBECONFIG=~/.kube/${{ matrix.kubeconfig_secret_name }}

          echo "ğŸ“Š Deployment status in namespace: ${NAMESPACE}"

          # Check deployments
          echo "ğŸš€ Deployments:"
          kubectl get deployments -n "${NAMESPACE}" --kubeconfig "${KUBECONFIG}" -o wide || echo "No deployments found"

          # Check pods
          echo "ğŸ¯ Pods:"
          kubectl get pods -n "${NAMESPACE}" --kubeconfig "${KUBECONFIG}" -o wide || echo "No pods found"

          # Check services
          echo "ğŸŒ Services:"
          kubectl get services -n "${NAMESPACE}" --kubeconfig "${KUBECONFIG}" -o wide || echo "No services found"

          # Check configmaps
          echo "âš™ï¸ ConfigMaps:"
          kubectl get configmaps -n "${NAMESPACE}" --kubeconfig "${KUBECONFIG}" || echo "No configmaps found"

          echo "::endgroup::"

      - name: ğŸ“‹ Collect Angular app logs
        if: github.event_name == 'push'
        run: |
          echo "::group::ğŸ“‹ Angular Application Logs"

          NAMESPACE="${{ vars.ORCHESTRATOR_LIBRARY_UI_NAMESPACE }}"
          RELEASE_NAME="${{ vars.ORCHESTRATOR_LIBRARY_UI_RELEASE_NAME }}"
          KUBECONFIG=~/.kube/${{ matrix.kubeconfig_secret_name }}

          echo "ğŸ” Looking for Angular app pods with label: app=${RELEASE_NAME}"

          POD_NAME=$(kubectl get pods -n "${NAMESPACE}" --kubeconfig "${KUBECONFIG}" -l app="${RELEASE_NAME}" -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")

          if [ ! -z "$POD_NAME" ]; then
            echo "âœ… Found Angular pod: ${POD_NAME}"

            echo "ğŸ“Š Pod details:"
            kubectl describe pod "${POD_NAME}" -n "${NAMESPACE}" --kubeconfig "${KUBECONFIG}"

            echo "ğŸ“‹ Pod logs (last 100 lines):"
            kubectl logs "${POD_NAME}" -n "${NAMESPACE}" --kubeconfig "${KUBECONFIG}" --tail=100 || echo "Could not retrieve logs"

            echo "ğŸ” Pod events:"
            kubectl get events -n "${NAMESPACE}" --kubeconfig "${KUBECONFIG}" --field-selector involvedObject.name="${POD_NAME}" --sort-by='.lastTimestamp'

          else
            echo "âŒ No Angular app pod found with label app=${RELEASE_NAME}"
            echo "Available pods in namespace:"
            kubectl get pods -n "${NAMESPACE}" --kubeconfig "${KUBECONFIG}"
          fi
          echo "::endgroup::"

      - name: ğŸ“‹ Collect K8s Proxy logs
        if: github.event_name == 'push'
        run: |
          echo "::group::ğŸ“‹ K8s Proxy Logs"

          NAMESPACE="${{ vars.ORCHESTRATOR_LIBRARY_UI_NAMESPACE }}"
          KUBECONFIG=~/.kube/${{ matrix.kubeconfig_secret_name }}

          echo "ğŸ” Looking for K8s proxy pods with label: app=aces-orchestrator-k8s-proxy"

          K8S_POD_NAME=$(kubectl get pods -n "${NAMESPACE}" --kubeconfig "${KUBECONFIG}" -l app=aces-orchestrator-k8s-proxy -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")

          if [ ! -z "$K8S_POD_NAME" ]; then
            echo "âœ… Found K8s proxy pod: ${K8S_POD_NAME}"

            echo "ğŸ“Š Pod details:"
            kubectl describe pod "${K8S_POD_NAME}" -n "${NAMESPACE}" --kubeconfig "${KUBECONFIG}"

            echo "ğŸ“‹ Pod logs (last 100 lines):"
            kubectl logs "${K8S_POD_NAME}" -n "${NAMESPACE}" --kubeconfig "${KUBECONFIG}" --tail=100 || echo "Could not retrieve K8s proxy logs"

            echo "ğŸ” Pod events:"
            kubectl get events -n "${NAMESPACE}" --kubeconfig "${KUBECONFIG}" --field-selector involvedObject.name="${K8S_POD_NAME}" --sort-by='.lastTimestamp'

          else
            echo "âŒ No K8s proxy pod found with label app=aces-orchestrator-k8s-proxy"
            echo "Available pods in namespace:"
            kubectl get pods -n "${NAMESPACE}" --kubeconfig "${KUBECONFIG}"
          fi

          echo "::endgroup::"

      - name: ğŸŒ Service connectivity test
        if: github.event_name == 'push'
        run: |
          echo "::group::ğŸŒ Service Connectivity Test"

          NAMESPACE="${{ vars.ORCHESTRATOR_LIBRARY_UI_NAMESPACE }}"
          RELEASE_NAME="${{ vars.ORCHESTRATOR_LIBRARY_UI_RELEASE_NAME }}"
          KUBECONFIG=~/.kube/${{ matrix.kubeconfig_secret_name }}

          echo "ğŸ” Testing service connectivity..."

          # Test main service
          echo "ğŸ¯ Testing main service: ${RELEASE_NAME}"
          kubectl get service "${RELEASE_NAME}" --kubeconfig "${KUBECONFIG}" -n "${NAMESPACE}" -o wide || echo "Main service not found"

          # Test K8s proxy service
          echo "ğŸ¯ Testing K8s proxy service: aces-orchestrator-k8s-proxy"
          kubectl get service "aces-orchestrator-k8s-proxy" --kubeconfig "${KUBECONFIG}" -n "${NAMESPACE}" -o wide || echo "K8s proxy service not found"

          # Show all endpoints
          echo "ğŸ”— All endpoints:"
          kubectl get endpoints -n "${NAMESPACE}" --kubeconfig "${KUBECONFIG}" || echo "No endpoints found"

          echo "::endgroup::"

      - name: ğŸ“Š Final deployment summary
        if: github.event_name == 'push'
        run: |
          echo "::group::ğŸ“Š Deployment Summary"

          echo "âœ… Deployment Summary:"
          echo "  ğŸ·ï¸ Image deployed: ${{ vars.ORCHESTRATOR_LIBRARY_UI_IMAGE_NAME }}:${{ needs.build-and-push.outputs.image_tag }}"
          echo "  ğŸ“¦ Release: ${{ vars.ORCHESTRATOR_LIBRARY_UI_RELEASE_NAME }}"
          echo "  ğŸ¯ Namespace: ${{ vars.ORCHESTRATOR_LIBRARY_UI_NAMESPACE }}"
          echo "  â° Completed at: $(date -u)"
          echo "  ğŸ—ï¸ Build time: ${{ needs.build-and-push.outputs.build_duration }} seconds"
          echo "  ğŸŒ Main service port: ${{ vars.ORCHESTRATOR_LIBRARY_UI_NODE_PORT }}"
          echo "  ğŸ”Œ Proxy service port: ${{ vars.K8S_PROXY_NODE_PORT }}"
          echo "  ğŸ“¡ Main service ingress host: ${{ vars.ORCHESTRATOR_LIBRARY_UI_INGRESS_HOST }}"
          echo "  ğŸ“¡ Proxy service ingress host: ${{ vars.K8S_PROXY_INGRESS_HOST }}"

          echo "ğŸ‰ Deployment completed successfully!"
          echo "::endgroup::"
